import os
import pathlib
import shutil
import uuid

from fastapi import APIRouter, Request, UploadFile, Depends
from sqlalchemy import literal_column, union_all, literal, distinct, func
from sqlalchemy import select
from sqlalchemy.orm import aliased

from app.db.base import async_session
from app.exceptions import UserNotExistsException
from app.models.comment import Comment as MComment
from app.models.like import Like as MLike
from app.models.shader import Shader as MShader
from app.models.user import User as MUser
from app.security.dependencies import get_current_user, get_current_user_id

router = APIRouter(
    prefix="/profile",
    tags=["profile"],
)


@router.get("/{user_id}")
async def get_profile_by_id(user_id: int, request: Request):
    # TODO переделать через один запрос в БД
    # TODO добавить возвращаемые значения

    # Получение информации о пользователе
    async with async_session() as session:
        result = await session.execute(
            select(MUser)
            .where(MUser.id == int(user_id))
        )
        user = result.scalars().first()

    if not user:
        raise UserNotExistsException

    # Получение списка активностей пользователя (лайков и комментариев)
    activities = []

    like_query = (
        select(MShader.id, MShader.title, MLike.created_at, literal("like").label("like"))
        .join(MLike, MShader.id == MLike.shader_id)
        .where(MLike.user_id == int(user_id))
    )

    comment_query = (
        select(MShader.id, MShader.title, MComment.created_at, literal("comment").label("comment"))
        .join(MComment, MShader.id == MComment.shader_id)
        .where(MComment.user_id == int(user_id))
    )

    forked_query = (
        select(MShader.id, MShader.title, MShader.created_at, literal("fork").label("fork"))
        .where((MShader.id_forked != None) & (MShader.user_id == int(user_id)))
    )

    activity_query = union_all(like_query, comment_query, forked_query)
    async with async_session() as session:
        result = await session.execute(activity_query.order_by(literal_column("created_at").desc()))
        for shader_id, shader_title, action_created, activity_type in result:
            activities.append({
                "shader_id": shader_id,
                "shader_title": shader_title,
                "action_created_at": action_created,
                "type": activity_type
            })

    # Получение списка всех шейдеров пользователя
    condition = (MShader.user_id == int(user_id)) & (MShader.visibility == True)

    if request.cookies.get("access_token") is not None:
        auth_user_id = await get_current_user_id(request)

        if auth_user_id == user_id:
            condition = MShader.user_id == int(user_id)

    MForkedShader = aliased(MShader)
    async with async_session() as session:
        result = await session.execute(
            select(MShader,
                   func.count(distinct(MLike.id)).label("likes"),
                   func.count(distinct(MComment.id)).label("comments"),
                   MForkedShader)
            .outerjoin(MLike, MShader.id == MLike.shader_id)
            .outerjoin(MComment, MShader.id == MComment.shader_id)
            .outerjoin(MForkedShader, MShader.id_forked == MForkedShader.id)
            .where(condition)
            .group_by(MShader.id)
            .order_by(MShader.created_at.desc())
        )
        shaders = []
        for shader, likes, comments, forked_shader in result:
            shaders.append({
                "id": shader.id,
                "title": shader.title,
                "code": shader.code,
                "description": shader.description,
                "created_at": shader.created_at,
                "updated_at": shader.updated_at,
                "id_forked": shader.id_forked,
                "visibility": shader.visibility,
                "likes": likes,
                "comments": comments,
                "forked_shader": forked_shader
            })

    user_data = {
        "id": user.id,
        "email": user.email,
        "name": user.name,
        "biography": user.biography,
        "avatar_url": user.avatar_url,
        "background_url": user.background_url,
        "created_at": user.created_at,
        "shaders": shaders,
        "activities": activities,
    }
    # TODO сделать запрос на получение всех публичных шейдеров для всех и приватных для авторизованного пользователя
    return user_data


@router.post("/avatar")
async def upload_avatar(avatar: UploadFile, user: MUser = Depends(get_current_user)):
    # Удаляем старый аватар
    if user.avatar_url and os.path.exists(f"public/{user.avatar_url}"):
        os.remove(f"public/{user.avatar_url}")

    # Сохраняем новый
    avatar_url = f"avatars/{uuid.uuid4().hex}{pathlib.Path(avatar.filename).suffix}"
    with open(f"public/{avatar_url}", "wb+") as f:
        shutil.copyfileobj(avatar.file, f)

    # Обновляем информацию в БД
    async with async_session() as session:
        user.avatar_url = avatar_url
        session.add(user)
        await session.commit()
        await session.refresh(user)

    return {"avatar_url": avatar_url}


@router.post("/background")
async def upload_avatar(background: UploadFile, user: MUser = Depends(get_current_user)):
    # Удаляем старый аватар
    if user.background_url and os.path.exists(f"public/{user.background_url}"):
        os.remove(f"public/{user.background_url}")

    # Сохраняем новый
    background_url = f"backgrounds/{uuid.uuid4().hex}{pathlib.Path(background.filename).suffix}"
    with open(f"public/{background_url}", "wb+") as f:
        shutil.copyfileobj(background.file, f)

    # Обновляем информацию в БД
    async with async_session() as session:
        user.background_url = background_url
        session.add(user)
        await session.commit()
        await session.refresh(user)

    return {"background_url": background_url}

@router.delete("/background")
async def delete_background(user: MUser = Depends(get_current_user)):
    # Удаляем старый аватар
    if user.background_url and os.path.exists(f"public/{user.background_url}"):
        os.remove(f"public/{user.background_url}")

    # Обновляем информацию в БД
    async with async_session() as session:
        user.background_url = None
        session.add(user)
        await session.commit()
        await session.refresh(user)

    return